The Go Routine

Por qué lo elegimos, cómo lo usamos y el día a día con Go
Mayo 2018

Luis Gabriel Gómez - Mercadolibre

* 

.image ./resources/gopherswrench.jpg _ 500

* Nuevo o curioso en Go?

*Golang Basics* -> [[https://goo.gl/nC6lyn][https://goo.gl/nC6lyn]]

* 

* En retrospectiva

- 8 años de go
- 3 años de go (en meli)
- Actualmente sirviendo millones de req/s (y en aumento!)


Cómo llegamos? Hacia dónde vamos?

* En perspectiva

- Python (27 años)
- PHP (23 años) 
- Java (22 años)
- Grails (12 años)
- NodeJS (8 años)

* Algunas preguntas

- Por qué go?
- To Go or not to Go, la cuestión
- Cómo lo usamos?
- Cómo trabajamos?


* Por qué go?

Blogposts y forobardos en la web sobre el tema sobran
.image ./resources/ghangman.jpg _ 300

* Por qué go?

En el contexto de meli:

- Performance
- Curva de aprendizaje
- Simpleza

* Performance

- Excelente concurrencia nativa y de bajo costo con goroutines (green threads)
- Garbage collector concurrente, pausas negligibles en APIs
- Compilación rápida, linkeo estático por defecto (y dynlink a partir de 1.5)
- Uso de memoria mínimo comparado con alternativas managed
- Punteros + slices nativos

* Curva de aprendizaje

- Extensa documentación disponible
- Poca dependencia en frameworks y plataformas de terceros
- Soporte de testing nativo

* Simpleza

- Lenguaje de reducida superficie sintáctica
- Linkeo estático = !(DLL hell) - por ahora...
- Poco cambalache objetoso gracias a duck typing
- El compilador ayuda, las referencias sin uso se consideran errores


* Go o no go, la cuestión

Como siempre, se trata de (intentar) seguir la máxima "The right tool for the right job"

Go es nuestra primera opción para:
- APIs core: Poca lógica de negocio, *muchos* requests por segundo
- Microservicios: Multitenancia sobre nuestro storage KV
- APIs cacheables: Poco uso de memoria permite masivos cache in-memory

Consideramos Java en lugar de Go para:
- Migraciones sin rediseño de sistemas "enterprise" (alias AbstractSingletonProxyFactoryBean)
- Extensibilidad y tuneo de librerías/productos ya basados en java (Hystrix, Cassandra)
- Ciertos middle-ends y orquestadores

